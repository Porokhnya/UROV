//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Формирователь трехфазного напряжения частотой 50 герц.
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#define LINE1 A4 // номер пина для линии 1
#define LINE2 A3 // номер пина для линии 2
#define LINE3 A2 // номер пина для линии 3 

#define DURATION 9875 //  сколько мкс между состояниями дадут нам меандр с частотой, близкой к 50 Гц
#define PHASE_SHIFT (DURATION/3) // сдвиг угла одной фазы относительно другой

//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Формирователь сигналов индуктивных датчиков (нижний и верхний)
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#define PULSE_PIN1 A1 // номер пина для генерации контрольных импульсов (400гц) индуктивного датчика №1
#define PULSE_PIN2 A0 // номер пина для генерации контрольных импульсов (400гц) индуктивного датчика №2

#define INDUCTIVE_DURATION 1100 // сколько микросекунд между состояниями дадут нам импульсы частотой 400-460 Гц для индуктивных датчиков

#define INDUCTIVE_SENSOR_BOTTOM_HALT_TIME  2000 // на сколько микросекунд прекращать генерацию импульсов нижнего индуктивного датчика при старте цикла
#define INDUCTIVE_SENSOR_TOP_HALT_TIME  2000 // на сколько микросекунд прекращать генерацию импульсов верхнего индуктивного датчика при окончании цикла


//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Формирователь сигнала срабатывания защиты
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#define SIGNAL_PIN 3  // номер пина, на который будет подаваться высокий уровень нужное кол-во микросекунд (имитация срабатывания реле)
#define SIGNAL_DURATION 10000 // сколько микросекунд держать уровень сигнала реле защиты
#define SIGNAL_LEVEL HIGH // уровень срабатывания сигнала реле защиты
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Формирователь сигналов энкодера
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#define PULSE_PIN3 A5 // номер пина для генерации импульсов энкодера №1
#define PULSE_PIN4 4 // номер пина для генерации импульсов энкодера №1

#define ENCODER_PHASE_SHIFT 2000 // сколько микросекунд сдвигать по фазе импульсы энкодера

//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Вход включения имитации срабатывания защиты (подключен к тумблеру на передней панели).
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#define GUARD_TRIGGER_PIN 5 // номер пина входа старта имитации срабатывания защиты(в исходном состоянии HIGH)
#define GUARD_TRIGGER_LEVEL LOW // по какому уровню срабатывает старт имитации защиты
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// КОНЕЦ НАСТРОЕК
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include "CorePinScenario.h"
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#define Serial SERIAL_PORT_USBVIRTUAL
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// пачка импульсов энкодера
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CorePinScenario encoderScene;
CorePinScenario encoderScene2;
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// сценарии для меандра на линиях
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CorePinScenario meander;
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// сценарии для генерации импульсов индуктивных датчиков
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CorePinScenario topInductive;
CorePinScenario bottomInductive;
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
uint32_t signalTimer = 0; // таймер срабатывания защиты

uint32_t inductiveBottomHaltTimer = 0;
bool inductiveBottomHaltEnabled = false;

uint32_t inductiveTopHaltTimer = 0;
bool inductiveTopHaltEnabled = false;

//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
typedef enum
{
  msNormal, // обычное состояние
  msStartSimulate, // начало симулирования срабатывания защиты
  msGenerateEncoderPulses, // генерируем импульсы энкодера
  msWaitForSwitchReleased, // ждём переключения в исходное состояние
  msHaltGenerateTopInductive, // прекращаем генерацию с верхнего индуктивного датчика
  
} MachineState;
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
MachineState state = msNormal; // состояние системы
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
bool isStartTriggered() // проверяем, не включили ли симуляцию?
{
  return digitalRead(GUARD_TRIGGER_PIN) == GUARD_TRIGGER_LEVEL;
}
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void makeEncoderPhaseShift() // сдвигаем импульсы энкодера по фазе
{
  encoderScene.begin();
  encoderScene2.begin();

  encoderScene.update();
  delayMicroseconds(ENCODER_PHASE_SHIFT);
  encoderScene2.update();
}
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void setup()
{
  Serial.begin(115200);


  // настраиваем линии меандра
  pinMode(LINE1, OUTPUT);
  pinMode(LINE2, OUTPUT);
  pinMode(LINE3, OUTPUT);

  // формируем сценарии для меандра на линиях
  // состояния на примере длительности промежутка PHASE_SHIFT в 1 секунду - расписаны в комментариях
  meander.add({LINE1, HIGH, PHASE_SHIFT}); // №1 - высокий 0с, №2 - низкий 2с, №3 - низкий 1с
  meander.add({LINE2, HIGH, PHASE_SHIFT}); // №1 - высокий 1с, №2 - высокий 0с, №3 - низкий 2с
  meander.add({LINE3, HIGH, PHASE_SHIFT}); // №1 - высокий 2с, №2 - высокий 1с, №3 - высокий 0с
  
  meander.add({LINE1, LOW, PHASE_SHIFT}); // №1 - низкий 0с, №2 - высокий 2с, №3 - высокий 1с
  meander.add({LINE2, LOW, PHASE_SHIFT}); // №1 - низкий 1с, №2 - низкий 0с, №3 - высокий 2с
  meander.add({LINE3, LOW, PHASE_SHIFT}); // №1 - низкий 2с, №2 - низкий 1с, №3 - низкий 0с
  

  // настраиваем индуктивные датчики
  pinMode(PULSE_PIN1,OUTPUT);
  pinMode(PULSE_PIN2,OUTPUT);

  // формируем сценарии импульсов индуктивных датчиков
  topInductive.add({PULSE_PIN1,HIGH,INDUCTIVE_DURATION});
  topInductive.add({PULSE_PIN1,LOW,INDUCTIVE_DURATION});

  bottomInductive.add({PULSE_PIN2,HIGH,INDUCTIVE_DURATION});
  bottomInductive.add({PULSE_PIN2,LOW,INDUCTIVE_DURATION});


  // настраиваем вход переключателя имитации защиты
  pinMode(GUARD_TRIGGER_PIN,(GUARD_TRIGGER_LEVEL) == LOW ? INPUT_PULLUP : INPUT);

  // настройка выхода сигнала имитации срабатывания защиты
  pinMode(SIGNAL_PIN,OUTPUT);
  digitalWrite(SIGNAL_PIN,!SIGNAL_LEVEL);


  // настраиваем выходы энкодера
  pinMode(PULSE_PIN3,OUTPUT);
  pinMode(PULSE_PIN4,OUTPUT);

  // добавляем тестовые импульсы
  encoderScene.setLoop(false);
  encoderScene2.setLoop(false);


  // формируем 250 импульсов разной длительности за 100 мс, или за 100 000 мкс
  // если импульсы равномерны, то длительность одного импульса составляет 400 микросекунд.
  // однако - мы до середины уменьшаем импульсы на определённый шаг, после середины - увеличиваем.
  // поэтому надо вычислить начальную длительность импульса.
  const uint16_t pulses = 250; // сколько всего импульсов надо сделать
  const uint16_t halfPulses = pulses/2;
  const uint32_t pulseTime = 200000; // за какое время, микросекунд
  const float maxPulseDuration = (1.*pulseTime)/pulses; // максимальная длительность импульса, микросекунд
  const float pulseDurationStep = maxPulseDuration/halfPulses; // шаг изменения длительности между импульсами
  uint8_t level = HIGH;

  // формируем половину импульсов по убыванию
  float curDuration = maxPulseDuration;

  for(uint16_t i=0;i<halfPulses;i++,curDuration -= pulseDurationStep)
  {
    uint32_t duration = round(curDuration);
    encoderScene.add({PULSE_PIN3, level, duration});
    encoderScene2.add({PULSE_PIN4, level, duration});
    level = !level;    
  }

  // затем добавляем половину импульсов по возрастанию
  for(uint16_t i=0;i<halfPulses;i++,curDuration += pulseDurationStep)
  {
    uint32_t duration = round(curDuration);
    encoderScene.add({PULSE_PIN3, level, duration});
    encoderScene2.add({PULSE_PIN4, level, duration});
    level = !level;    
  }

  /*
  unsigned long duration = 40000; // максимальная длительность импульса, микросекунд
  uint8_t level = HIGH;

  // Формируем 30 импульса первого графика прерывания. Желтый цвет графика.
  // сперва добавляем 10 импульсов по убыванию, от 20 мс до 2 мс, с шагом 2 мс

  for (int i = 0; i < 10; i++, duration -= 2000)
  {
    encoderScene.add({PULSE_PIN3, level, duration});
    encoderScene2.add({PULSE_PIN4, level, duration});
    level = !level;
  }
  for (int i = 0; i < 10; i++, duration -= 1000)
  {
    encoderScene.add({PULSE_PIN3, level, duration});
    encoderScene2.add({PULSE_PIN4, level, duration});
    level = !level;
  }

  for (int i = 0; i < 10; i++, duration -= 100)
  {
    encoderScene.add({PULSE_PIN3, level, duration});
    encoderScene2.add({PULSE_PIN4, level, duration});
    level = !level;
  }

  // затем добавляем 10 импульсов по возрастанию
  for (int i = 0; i < 10; i++, duration += 1000)
  {
    encoderScene.add({PULSE_PIN3, level, duration});
    encoderScene2.add({PULSE_PIN4, level, duration});
    level = !level;
  }
  // затем добавляем 15 импульсов по возрастанию
  for (int i = 0; i < 15; i++, duration += 1600)
  {
    encoderScene.add({PULSE_PIN3, level, duration});
    encoderScene2.add({PULSE_PIN4, level, duration});
    level = !level;
  }
  // затем добавляем 5 импульсов по возрастанию
  for (int i = 0; i < 5; i++, duration += 600)
  {
    encoderScene.add({PULSE_PIN3, level, duration});
    encoderScene2.add({PULSE_PIN4, level, duration});
    level = !level;
  }
  */

  // добавляем установку низкого уровня
  encoderScene.add({PULSE_PIN3, LOW, 10000});
  encoderScene2.add({PULSE_PIN4, LOW, 10000});
  
  Serial.println("READY");

}
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void loop()
{
  // обновляем меандры
  meander.update();

  // обновляем индуктивные датчики
  topInductive.update();
  bottomInductive.update();


  // проверяем, не надо ли возобновить генерацию импульсов с нижнего индуктивного датчика
  if(inductiveBottomHaltEnabled && micros() - inductiveBottomHaltTimer > INDUCTIVE_SENSOR_BOTTOM_HALT_TIME)
  {
    inductiveBottomHaltTimer = 0;
    inductiveBottomHaltEnabled = false;
    // начинаем генерацию сигналов нижнего индуктивного датчика с начала
    bottomInductive.begin();
    bottomInductive.enable();
  }  
        
  switch(state)
  {
    case msNormal:
    {
      // нормальное состояние системы - генерируем меандры и импульсы индуктивных датчиков

      // проверяем, не включили ли симуляцию?
      if(isStartTriggered())
      {
        digitalWrite(SIGNAL_PIN,SIGNAL_LEVEL); // выдаём импульс на реле защиты
        signalTimer = micros(); // запоминаем время начала выдачи импульса на реле защиты

        // прекращаем генерацию импульсов нижнего индуктивного датчика
        bottomInductive.disable();
        digitalWrite(PULSE_PIN2,LOW);
        inductiveBottomHaltEnabled = true;
        inductiveBottomHaltTimer = micros();

        state = msStartSimulate; // переключаемся на начало симулирования срабатывания защиты        
      }
    }
    break; // msNormal

    case msStartSimulate: // мы в режиме начала симуляции
    {
      
      if(micros() - signalTimer > SIGNAL_DURATION)
      {
        // всё, не надо выдавать импульс на реле защиты
        digitalWrite(SIGNAL_PIN,!SIGNAL_LEVEL); // снимаем импульс с реле защиты

        makeEncoderPhaseShift(); // сдвигаем фазы импульсов энкодера
        
        // переключаемся на генерацию импульсов энкодера
        state = msGenerateEncoderPulses;
      }
    }
    break; // msStartSimulate


    case msGenerateEncoderPulses: // генерируем импульсы энкодера
    {
  
      // генерируем импульсы энкодера
      encoderScene.update();
      encoderScene2.update();

      // проверяем, не закончили ли генерировать импульсы энкодера?
      // поскольку у нас второй сценарий импульсов сдвинут по фазе вперёд, то мы ждём именно его
      if(encoderScene2.isDone())
      {
        // прекращаем генерацию импульсов верхнего индуктивного датчика
        topInductive.disable();
        digitalWrite(PULSE_PIN1,LOW);
        inductiveTopHaltTimer = micros();
        inductiveTopHaltEnabled = true;
        
        // генерация импульсов закончена, переключаемся на ветку ожидания переключения тумблера в исходное состояние
        state = msHaltGenerateTopInductive;
      }
      
    }
    break; // msGenerateEncoderPulses

    case msHaltGenerateTopInductive:
    {
                  
      if(inductiveTopHaltEnabled && micros() - inductiveTopHaltTimer > INDUCTIVE_SENSOR_TOP_HALT_TIME)
      {
        inductiveTopHaltTimer = 0;
        inductiveTopHaltEnabled = false;
        
        topInductive.begin();
        topInductive.enable();

        // генерация импульсов закончена, переключаемся на ветку ожидания переключения тумблера в исходное состояние
        state = msWaitForSwitchReleased;
        
      }
    }
    break;

    case msWaitForSwitchReleased: // ждём, когда кнопку "Старт" переведут в нормальное состояние
    {
      
      if(!isStartTriggered())
      {
        // кнопку "Старт" перевели в исходное состояние, возвращаемся в режим ожидания начала симуляции
        state = msNormal;
      }
    }
    break; // msWaitForSwitchReleased
    
  } // switch
}
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
