//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Формирователь трехфазного напряжения частотой 50 герц.
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#define LINE1 A4 // номер пина для линии 1
#define LINE2 A3 // номер пина для линии 2
#define LINE3 A2 // номер пина для линии 3 

#define DURATION 9875 //  сколько мкс между состояниями дадут нам меандр с частотой, близкой к 50 Гц
#define PHASE_SHIFT (DURATION/3) // сдвиг угла одной фазы относительно другой

//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Формирователь сигналов индуктивных датчиков (нижний и верхний)
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#define PULSE_PIN1 A1 // номер пина для генерации контрольных импульсов (400гц) индуктивного датчика №1
#define PULSE_PIN2 A0 // номер пина для генерации контрольных импульсов (400гц) индуктивного датчика №2

#define INDUCTIVE_DURATION 1100 // сколько микросекунд между состояниями дадут нам импульсы частотой 400-460 Гц для индуктивных датчиков

//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Формирователь сигнала срабатывания защиты
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#define SIGNAL_PIN 3  // номер пина, на который будет подаваться высокий уровень нужное кол-во микросекунд (имитация срабатывания реле)
#define SIGNAL_DURATION 10000 // сколько микросекунд держать уровень сигнала реле защиты
#define SIGNAL_LEVEL HIGH // уровень срабатывания сигнала реле защиты
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Формирователь сигналов энкодера
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#define PULSE_PIN3 A5 // номер пина для генерации импульсов энкодера №1
#define PULSE_PIN4 4 // номер пина для генерации импульсов энкодера №1

#define ENCODER_PHASE_SHIFT 2000 // сколько микросекунд сдвигать по фазе импульсы энкодера

//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Вход включения имитации срабатывания защиты (подключен к тумблеру на передней панели).
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#define GUARD_TRIGGER_PIN 5 // номер пина входа старта имитации срабатывания защиты(в исходном состоянии HIGH)
#define GUARD_TRIGGER_LEVEL LOW // по какому уровню срабатывает старт имитации защиты
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// КОНЕЦ НАСТРОЕК
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include "CorePinScenario.h"
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#define Serial SERIAL_PORT_USBVIRTUAL
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// пачка импульсов энкодера
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CorePinScenario encoderScene;
CorePinScenario encoderScene2;
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// сценарии для меандра на линиях
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CorePinScenario meander;
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// сценарии для генерации импульсов индуктивных датчиков
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CorePinScenario inductiveScene1;
CorePinScenario inductiveScene2;
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
uint32_t signalTimer = 0; // таймер срабатывания защиты
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
typedef enum
{
  msNormal, // обычное состояние
  msStartSimulate, // начало симулирования срабатывания защиты
  msGenerateEncoderPulses, // генерируем импульсы энкодера
  msWaitForSwitchReleased, // ждём переключения в исходное состояние
  
} MachineState;
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
MachineState state = msNormal; // состояние системы
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
bool isStartTriggered() // проверяем, не включили ли симуляцию?
{
  return digitalRead(GUARD_TRIGGER_PIN) == GUARD_TRIGGER_LEVEL;
}
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void makeEncoderPhaseShift() // сдвигаем импульсы энкодера по фазе
{
  encoderScene.begin();
  encoderScene2.begin();

  encoderScene.update();
  delayMicroseconds(ENCODER_PHASE_SHIFT);
  encoderScene2.update();
}
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void setup()
{
  Serial.begin(115200);


  // настраиваем линии меандра
  pinMode(LINE1, OUTPUT);
  pinMode(LINE2, OUTPUT);
  pinMode(LINE3, OUTPUT);

  // формируем сценарии для меандра на линиях
  // состояния на примере длительности промежутка PHASE_SHIFT в 1 секунду - расписаны в комментариях
  meander.add({LINE1, HIGH, PHASE_SHIFT}); // №1 - высокий 0с, №2 - низкий 2с, №3 - низкий 1с
  meander.add({LINE2, HIGH, PHASE_SHIFT}); // №1 - высокий 1с, №2 - высокий 0с, №3 - низкий 2с
  meander.add({LINE3, HIGH, PHASE_SHIFT}); // №1 - высокий 2с, №2 - высокий 1с, №3 - высокий 0с
  
  meander.add({LINE1, LOW, PHASE_SHIFT}); // №1 - низкий 0с, №2 - высокий 2с, №3 - высокий 1с
  meander.add({LINE2, LOW, PHASE_SHIFT}); // №1 - низкий 1с, №2 - низкий 0с, №3 - высокий 2с
  meander.add({LINE3, LOW, PHASE_SHIFT}); // №1 - низкий 2с, №2 - низкий 1с, №3 - низкий 0с
  

  // настраиваем индуктивные датчики
  pinMode(PULSE_PIN1,OUTPUT);
  pinMode(PULSE_PIN2,OUTPUT);

  // формируем сценарии импульсов индуктивных датчиков
  inductiveScene1.add({PULSE_PIN1,HIGH,INDUCTIVE_DURATION});
  inductiveScene1.add({PULSE_PIN1,LOW,INDUCTIVE_DURATION});

  inductiveScene2.add({PULSE_PIN2,HIGH,INDUCTIVE_DURATION});
  inductiveScene2.add({PULSE_PIN2,LOW,INDUCTIVE_DURATION});


  // настраиваем вход переключателя имитации защиты
  pinMode(GUARD_TRIGGER_PIN,(GUARD_TRIGGER_LEVEL) == LOW ? INPUT_PULLUP : INPUT);

  // настройка выхода сигнала имитации срабатывания защиты
  pinMode(SIGNAL_PIN,OUTPUT);
  digitalWrite(SIGNAL_PIN,!SIGNAL_LEVEL);


  // настраиваем выходы энкодера
  pinMode(PULSE_PIN3,OUTPUT);
  pinMode(PULSE_PIN4,OUTPUT);

  // добавляем тестовые импульсы
  encoderScene.setLoop(false);
  encoderScene2.setLoop(false);

  unsigned long duration = 40000;
  uint8_t level = HIGH;

  // Формируем 30 импульса первого графика прерывания. Желтый цвет графика.
  // сперва добавляем 10 импульсов по убыванию, от 20 мс до 2 мс, с шагом 2 мс

  for (int i = 0; i < 10; i++, duration -= 2000)
  {
    encoderScene.add({PULSE_PIN3, level, duration});
    encoderScene2.add({PULSE_PIN4, level, duration});
    level = !level;
  }
  for (int i = 0; i < 10; i++, duration -= 1000)
  {
    encoderScene.add({PULSE_PIN3, level, duration});
    encoderScene2.add({PULSE_PIN4, level, duration});
    level = !level;
  }

  for (int i = 0; i < 10; i++, duration -= 100)
  {
    encoderScene.add({PULSE_PIN3, level, duration});
    encoderScene2.add({PULSE_PIN4, level, duration});
    level = !level;
  }

  // затем добавляем 10 импульсов по возрастанию
  for (int i = 0; i < 10; i++, duration += 1000)
  {
    encoderScene.add({PULSE_PIN3, level, duration});
    encoderScene2.add({PULSE_PIN4, level, duration});
    level = !level;
  }
  // затем добавляем 15 импульсов по возрастанию
  for (int i = 0; i < 15; i++, duration += 1600)
  {
    encoderScene.add({PULSE_PIN3, level, duration});
    encoderScene2.add({PULSE_PIN4, level, duration});
    level = !level;
  }
  // затем добавляем 5 импульсов по возрастанию
  for (int i = 0; i < 5; i++, duration += 600)
  {
    encoderScene.add({PULSE_PIN3, level, duration});
    encoderScene2.add({PULSE_PIN4, level, duration});
    level = !level;
  }

  // добавляем установку низкого уровня
  encoderScene.add({PULSE_PIN3, LOW, 10000});
  encoderScene2.add({PULSE_PIN4, LOW, 10000});
  
  Serial.println("READY");

}
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void loop()
{
  switch(state)
  {
    case msNormal:
    {
      // нормальное состояние системы - генерируем меандры и импульсы индуктивных датчиков

      // обновляем меандры
      meander.update();

      // обновляем индуктивные датчики
      inductiveScene1.update();
      inductiveScene2.update();

      // проверяем, не включили ли симуляцию?
      if(isStartTriggered())
      {
        digitalWrite(SIGNAL_PIN,SIGNAL_LEVEL); // выдаём импульс на реле защиты
        signalTimer = micros(); // запоминаем время начала выдачи импульса на реле защиты        

        state = msStartSimulate; // переключаемся на начало симулирования срабатывания защиты        
      }
    }
    break; // msNormal

    case msStartSimulate: // мы в режиме начала симуляции
    {
      // обновляем меандры
      meander.update();

      // обновляем только верхний индуктивный датчик
      inductiveScene1.update();
      
      // проверяем, не настало ли время возобновить генерирование импульсов второго индуктивного датчика?
      if(micros() - signalTimer > SIGNAL_DURATION)
      {
        // всё, не надо выдавать импульс на реле защиты
        digitalWrite(SIGNAL_PIN,!SIGNAL_LEVEL); // снимаем импульс с реле защиты

        // и начинаем генерацию сигналов нижнего индуктивного датчика с начала
        inductiveScene2.begin();

        makeEncoderPhaseShift(); // сдвигаем фазы импульсов энкодера
        
        // переключаемся на генерацию импульсов энкодера
        state = msGenerateEncoderPulses;
      }
    }
    break; // msStartSimulate


    case msGenerateEncoderPulses: // генерируем импульсы энкодера
    {
      // обновляем меандры
      meander.update();

      // обновляем индуктивные датчики
      inductiveScene1.update();
      inductiveScene2.update();
      
      // генерируем импульсы энкодера
      encoderScene.update();
      encoderScene2.update();

      // проверяем, не закончили ли генерировать импульсы энкодера?
      // поскольку у нас второй сценарий импульсов сдвинут по фазе вперёд, то мы ждём именно его
      if(encoderScene2.isDone())
      {
        // генерация импульсов закончена, переключаемся на ветку ожидания переключения тумблера в исходное состояние
        state = msWaitForSwitchReleased;
      }
      
    }
    break; // msGenerateEncoderPulses

    case msWaitForSwitchReleased: // ждём, когда кнопку "Старт" переведут в нормальное состояние
    {
      // обновляем меандры
      meander.update();

      // обновляем только нижний индуктивный датчик
      inductiveScene2.update();

      if(!isStartTriggered())
      {
        // кнопку "Старт" перевели в исходное состояние, возвращаемся в режим ожидания начала симуляции
        state = msNormal;
      }

    }
    break; // msWaitForSwitchReleased
    
  } // switch
}
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
